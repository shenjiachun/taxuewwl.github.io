
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现 | 朝·闻·道</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="SnoWalker">
    

    <meta name="keywords" content="Sharding-JDBC">
    <meta name="description" content="本文是 “跟我学Sharding-JDBC” 系列的第四篇，我将带领读者一起了解下Sharding-JDBC的数据分片规则并通过实例实现自定义分片策略的开发实现。

Sharding-JDBC中的分片策略有两个维度，分别是：数据源分片策略（DatabaseShardingStrategy）、表分片策略（TableShardingStrategy）。
其中，数据源分片策略表示：数据路由到的物理目标">
<meta property="og:type" content="article">
<meta property="og:title" content="跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现">
<meta property="og:url" content="http://wuwenliang.net/2019/03/26/跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现/index.html">
<meta property="og:site_name" content="朝·闻·道">
<meta property="og:description" content="本文是 “跟我学Sharding-JDBC” 系列的第四篇，我将带领读者一起了解下Sharding-JDBC的数据分片规则并通过实例实现自定义分片策略的开发实现。

Sharding-JDBC中的分片策略有两个维度，分别是：数据源分片策略（DatabaseShardingStrategy）、表分片策略（TableShardingStrategy）。
其中，数据源分片策略表示：数据路由到的物理目标">
<meta property="og:image" content="http://wuwenliang.net/2019/03/26/跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现/./sharding.png">
<meta property="og:updated_time" content="2019-03-26T16:41:30.109Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现">
<meta name="twitter:description" content="本文是 “跟我学Sharding-JDBC” 系列的第四篇，我将带领读者一起了解下Sharding-JDBC的数据分片规则并通过实例实现自定义分片策略的开发实现。

Sharding-JDBC中的分片策略有两个维度，分别是：数据源分片策略（DatabaseShardingStrategy）、表分片策略（TableShardingStrategy）。
其中，数据源分片策略表示：数据路由到的物理目标">
<meta name="twitter:image" content="http://wuwenliang.net/2019/03/26/跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现/./sharding.png">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="朝·闻·道" title="朝·闻·道"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="朝·闻·道">朝·闻·道</a></h1>
				<h2 class="blog-motto">SnoWalker&#39;s Blog</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/old/index.html">旧版</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:wuwenliang.net">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/03/26/跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现/" title="跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现" itemprop="url">跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="SnoWalker" target="_blank" itemprop="author">SnoWalker</a>
		
  <p class="article-time">
    <time datetime="2019-03-26T07:51:16.000Z" itemprop="datePublished"> 发表于 2019-03-26</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#了解Sharding-JDBC的数据分片策略"><span class="toc-number">1.</span> <span class="toc-text">了解Sharding-JDBC的数据分片策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#精确分片算法–PreciseShardingAlgorithm"><span class="toc-number">1.1.</span> <span class="toc-text">精确分片算法–PreciseShardingAlgorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#范围分片算法–RangeShardingAlgorithm"><span class="toc-number">1.2.</span> <span class="toc-text">范围分片算法–RangeShardingAlgorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复合分片算法–ComplexKeysShardingAlgorithm"><span class="toc-number">1.3.</span> <span class="toc-text">复合分片算法–ComplexKeysShardingAlgorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hint分片算法–HintShardingAlgorithm"><span class="toc-number">1.4.</span> <span class="toc-text">Hint分片算法–HintShardingAlgorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准分片策略–StandardShardingStrategy"><span class="toc-number">1.5.</span> <span class="toc-text">标准分片策略–StandardShardingStrategy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复合分片策略–ComplexShardingStrategy"><span class="toc-number">1.6.</span> <span class="toc-text">复合分片策略–ComplexShardingStrategy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#行表达式分片策略–InlineShardingStrategy"><span class="toc-number">1.7.</span> <span class="toc-text">行表达式分片策略–InlineShardingStrategy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hint分片策略–HintShardingStrategy"><span class="toc-number">1.8.</span> <span class="toc-text">Hint分片策略–HintShardingStrategy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不分片策略–NoneShardingStrategy"><span class="toc-number">1.9.</span> <span class="toc-text">不分片策略–NoneShardingStrategy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实战–自定义复合分片策略"><span class="toc-number">2.</span> <span class="toc-text">实战–自定义复合分片策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#场景回顾"><span class="toc-number">2.1.</span> <span class="toc-text">场景回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开发自定义复合分库策略"><span class="toc-number">2.2.</span> <span class="toc-text">开发自定义复合分库策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#核心逻辑"><span class="toc-number">2.2.1.</span> <span class="toc-text">核心逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#核心逻辑解析"><span class="toc-number">2.2.2.</span> <span class="toc-text">核心逻辑解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开发自定义复合分表策略"><span class="toc-number">2.3.</span> <span class="toc-text">开发自定义复合分表策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#核心逻辑解析-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">核心逻辑解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试前置–配置自定义分库分表策略"><span class="toc-number">2.4.</span> <span class="toc-text">测试前置–配置自定义分库分表策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试用例A–新增订单数据"><span class="toc-number">2.5.</span> <span class="toc-text">测试用例A–新增订单数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试用例B–通过订单号查询订单明细"><span class="toc-number">2.6.</span> <span class="toc-text">测试用例B–通过订单号查询订单明细</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录：解析枚举类的values-方法"><span class="toc-number">4.</span> <span class="toc-text">附录：解析枚举类的values()方法</span></a></li></ol>
		
		</div>
		
		<blockquote>
<p>本文是 “跟我学Sharding-JDBC” 系列的第四篇，我将带领读者一起了解下Sharding-JDBC的数据分片规则并通过实例实现自定义分片策略的开发实现。</p>
</blockquote>
<p>Sharding-JDBC中的分片策略有两个维度，分别是：数据源分片策略（DatabaseShardingStrategy）、表分片策略（TableShardingStrategy）。</p>
<p>其中，数据源分片策略表示：数据路由到的物理目标数据源，表分片策略表示数据被路由到的目标表。</p>
<p>特别的，表分片策略是依赖于数据源分片策略的，也就是说要先分库再分表。</p>
<p>这里贴一张盗来的图</p>
<p><img src="/2019/03/26/跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现/./sharding.png" alt="Sharding-JDBC分片策略代码架构"></p>
<a id="more"></a>
<h2 id="了解Sharding-JDBC的数据分片策略"><a href="#了解Sharding-JDBC的数据分片策略" class="headerlink" title="了解Sharding-JDBC的数据分片策略"></a>了解Sharding-JDBC的数据分片策略</h2><p>Sharding-JDBC的分片策略包含了分片键和分片算法。由于分片算法与业务实现紧密相关，因此Sharding-JDBC没有提供内置的分片算法，而是通过分片策略将各种场景提炼出来，提供了高层级的抽象，通过提供接口让开发者自行实现分片算法。</p>
<p>以下内容引用自官方文档。<a href="https://shardingsphere.apache.org/document/legacy/3.x/document/cn/features/sharding/concept/sharding/" target="_blank" rel="external">官方文档</a></p>
<p>首先介绍四种分片算法。</p>
<blockquote>
<p>通过分片算法将数据分片，支持通过=、BETWEEN和IN分片。<br>分片算法需要应用方开发者自行实现，可实现的灵活度非常高。</p>
<p>目前提供4种分片算法。由于分片算法和业务实现紧密相关，<br>因此并未提供内置分片算法，而是通过分片策略将各种场景提炼出来，<br>提供更高层级的抽象，并提供接口让应用开发者自行实现分片算法。</p>
</blockquote>
<h3 id="精确分片算法–PreciseShardingAlgorithm"><a href="#精确分片算法–PreciseShardingAlgorithm" class="headerlink" title="精确分片算法–PreciseShardingAlgorithm"></a>精确分片算法–PreciseShardingAlgorithm</h3><p>用于处理使用单一键作为分片键的=与IN进行分片的场景。需要配合StandardShardingStrategy使用。</p>
<h3 id="范围分片算法–RangeShardingAlgorithm"><a href="#范围分片算法–RangeShardingAlgorithm" class="headerlink" title="范围分片算法–RangeShardingAlgorithm"></a>范围分片算法–RangeShardingAlgorithm</h3><p>用于处理使用单一键作为分片键的BETWEEN AND进行分片的场景。需要配合StandardShardingStrategy使用。</p>
<h3 id="复合分片算法–ComplexKeysShardingAlgorithm"><a href="#复合分片算法–ComplexKeysShardingAlgorithm" class="headerlink" title="复合分片算法–ComplexKeysShardingAlgorithm"></a>复合分片算法–ComplexKeysShardingAlgorithm</h3><p>用于处理使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度。需要配合ComplexShardingStrategy使用。</p>
<p><strong>注</strong> ： 我们在业务开发中，经常有根据用户id 查询某用户的记录列表，又有根据某个业务主键查询该用户的某记录的需求，这就需要用到复合分片算法。比如，订单表中，我们既需要查询某个userId的某时间段内的订单列表数据，又需要根据orderId查询某条订单数据。这里，orderId与userId就属于复合分片键。</p>
<h3 id="Hint分片算法–HintShardingAlgorithm"><a href="#Hint分片算法–HintShardingAlgorithm" class="headerlink" title="Hint分片算法–HintShardingAlgorithm"></a>Hint分片算法–HintShardingAlgorithm</h3><p>Hint分片指的是对于分片字段非SQL决定，而由其他外置条件决定的场景，可以通过使用SQL Hint灵活注入分片字段。</p>
<p>Hint分片策略是绕过SQL解析的，因此能够通过实现该算法来实现Sharding-JDBC不支持的语法限制。</p>
<p>用于处理使用Hint行分片的场景。需要配合HintShardingStrategy使用。</p>
<blockquote>
<p>接着介绍下五种分片策略。</p>
</blockquote>
<h3 id="标准分片策略–StandardShardingStrategy"><a href="#标准分片策略–StandardShardingStrategy" class="headerlink" title="标准分片策略–StandardShardingStrategy"></a>标准分片策略–StandardShardingStrategy</h3><p>提供对SQL语句中的=, IN和BETWEEN AND的分片操作支持。StandardShardingStrategy只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。PreciseShardingAlgorithm是必选的，用于处理=和IN的分片。RangeShardingAlgorithm是可选的，用于处理BETWEEN AND分片，如果不配置RangeShardingAlgorithm，SQL中的BETWEEN AND将按照全库路由处理。</p>
<h3 id="复合分片策略–ComplexShardingStrategy"><a href="#复合分片策略–ComplexShardingStrategy" class="headerlink" title="复合分片策略–ComplexShardingStrategy"></a>复合分片策略–ComplexShardingStrategy</h3><p>提供对SQL语句中的=, IN和BETWEEN AND的分片操作支持。ComplexShardingStrategy支持多分片键，由于多分片键之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度。</p>
<p>这里体现出框架设计者对设计原则的透彻理解，将变更点暴露给用户，将不变的封装在内部，明确的划分了抽象和实现的界限，这是值得我们学习的。</p>
<h3 id="行表达式分片策略–InlineShardingStrategy"><a href="#行表达式分片策略–InlineShardingStrategy" class="headerlink" title="行表达式分片策略–InlineShardingStrategy"></a>行表达式分片策略–InlineShardingStrategy</h3><p>使用Groovy的表达式，提供对SQL语句中的=和IN的分片操作支持，只支持单分片键。对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: t<em>user</em>$-&gt;{u_id % 8} 表示t_user表根据u_id模8，而分成8张表，表名称为t_user_0到t_user_7。</p>
<p>上一篇文章中，我就是使用这个方式进行了demo的开发和讲解，对于快速体验Sharding-JDBC的魅力是很有意义的，但是这种方式对于复杂的业务支持程度就差一些，因此实际的业务开发中还是推荐使用复合分片策略–ComplexShardingStrategy。</p>
<h3 id="Hint分片策略–HintShardingStrategy"><a href="#Hint分片策略–HintShardingStrategy" class="headerlink" title="Hint分片策略–HintShardingStrategy"></a>Hint分片策略–HintShardingStrategy</h3><p>通过Hint而非SQL解析的方式分片的策略。</p>
<h3 id="不分片策略–NoneShardingStrategy"><a href="#不分片策略–NoneShardingStrategy" class="headerlink" title="不分片策略–NoneShardingStrategy"></a>不分片策略–NoneShardingStrategy</h3><p>该策略为不分片的策略。</p>
<h2 id="实战–自定义复合分片策略"><a href="#实战–自定义复合分片策略" class="headerlink" title="实战–自定义复合分片策略"></a>实战–自定义复合分片策略</h2><p>由于目的为贴近实战，因此着重讲解如何实现复杂分片策略，即实现ComplexShardingStrategy接口定制生产可用的分片策略。</p>
<h3 id="场景回顾"><a href="#场景回顾" class="headerlink" title="场景回顾"></a>场景回顾</h3><p>首先回顾一下业务场景，我们对订单进行分库分表，分为4库8表，复合分片键为user_id及order_id。</p>
<p>对用户进行分库分表，分为4库16表，分片键为user_id。</p>
<p>对订单表进行分库分表，分为4库8表，分片键为order_id，查询条件为user_id、order_id。</p>
<blockquote>
<p>我们的业务流程如下：</p>
</blockquote>
<ol>
<li>根据一个外部路由id(如：支付宝uid、微信openId等)生成系统内部的用户user_id</li>
<li>根据系统内部user_id生成业务id，如：order_id、account_id等</li>
<li>根据外部id查询，获得系统内部user_id</li>
<li>根据系统内部user_id查询用户的所有订单信息</li>
<li>根据订单号order_id查询单条订单明细数据</li>
</ol>
<p>在上篇文章 <a href="http://wuwenliang.net/2019/03/25/%E8%B7%9F%E6%88%91%E5%AD%A6shardingjdbc%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%BB%E9%94%AE%E5%8F%8A%E5%85%B6%E8%87%AA%E5%AE%9A%E4%B9%89/">跟我学shardingjdbc之分布式主键及其自定义</a> 中，我们完成了自定义分布式主键的生成，本节中，我将基于该分布式主键生成规则，配合Sharding-JDBC的复合分片策略接口，开发符合上述业务流程的复合分片规则，该规则已经在我们线上稳定运行，读者朋友可以借鉴并运用到自己的生产环境。</p>
<h3 id="开发自定义复合分库策略"><a href="#开发自定义复合分库策略" class="headerlink" title="开发自定义复合分库策略"></a>开发自定义复合分库策略</h3><blockquote>
<p>我们需要开发复合分库、分表两个策略，首先开发分库策略。</p>
</blockquote>
<p>定义自定义复合分库策略实现类：SnoWalkerComplexShardingDB.java，实现 <strong>ComplexKeysShardingAlgorithm</strong>  接口。需要重写其 <strong>doSharding(Collection availableTargetNames, Collection shardingValues)</strong> 方法。</p>
<blockquote>
<p> <strong>doSharding(Collection availableTargetNames, Collection shardingValues)</strong>  方法返回值为：物理数据源、物理表分片结果，如：ds0, t_user_0000，Sharding-JDBC会将数据路由至物理分片。</p>
</blockquote>
<h4 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h4><blockquote>
<p>这里是方法的关键逻辑</p>
</blockquote>
<pre><code>/**
 * @param availableTargetNames 可用数据源集合
 * @param shardingValues   分片键
 * @return sharding results for data sources or tables&apos;s names
 */
@Override
public Collection&lt;String&gt; doSharding(Collection&lt;String&gt; availableTargetNames, Collection&lt;ShardingValue&gt; shardingValues) {

    // 0. 打印数据源集合 及 分片键属性集合
    log.info(&quot;availableTargetNames:&quot; + JSON.toJSONString(availableTargetNames) + &quot;,shardingValues:&quot; + JSON.toJSONString(shardingValues));
    // availableTargetNames:[&quot;ds0&quot;,&quot;ds1&quot;,&quot;ds2&quot;,&quot;ds3&quot;],
    // shardingValues:[{&quot;columnName&quot;:&quot;user_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;UD020003011903261545436593200002&quot;]},
    //                {&quot;columnName&quot;:&quot;order_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;OD000000011903261545475143200001&quot;]}]
    List&lt;String&gt; shardingResults = new ArrayList&lt;&gt;();

    // 1. 遍历分片键集合，匹配数据源
    for (ShardingValue var : shardingValues) {

        ListShardingValue&lt;String&gt; listShardingValue = (ListShardingValue&lt;String&gt;)var;
        List&lt;String&gt; shardingValue = (List&lt;String&gt;)listShardingValue.getValues();

        // shardingValue:[&quot;UD020003011903261545436593200002&quot;]
        log.info(&quot;shardingValue:&quot; + JSON.toJSONString(shardingValue));

        // 2. 获取数据源索引值
        String index = getIndex(listShardingValue.getLogicTableName(),
                                listShardingValue.getColumnName(),
                                shardingValue.get(0));

        // 3. 循环匹配数据源，匹配到则退出循环
        for (String name : availableTargetNames) {
            // 4. 获取逻辑数据源索引后缀，即 0，1，2，3
            String nameSuffix = name.substring(ShardingConstant.LOGIC_DB_PREFIX_LENGTH);
            // 5. 当且仅当availableTargetNames中的数据源索引与路由值对应的分片索引相同退出循环
            if (nameSuffix.equals(index)) {
                // 6. 添加到分片结果集合
                shardingResults.add(name);
                break;
            }
        }

        //匹配到一种路由规则就可以退出
        if (shardingResults.size() &gt; 0) {
            break;
        }
    }

    return shardingResults;
}
</code></pre><h4 id="核心逻辑解析"><a href="#核心逻辑解析" class="headerlink" title="核心逻辑解析"></a>核心逻辑解析</h4><blockquote>
<p>梳理一下逻辑，首先介绍一下该方法的入参</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">availableTargetNames</td>
<td style="text-align:left">有效的物理数据源，即配置文件中的 ds0,ds1,ds2,ds3</td>
</tr>
<tr>
<td style="text-align:left">shardingValues</td>
<td style="text-align:left">分片属性，如：{“columnName”:”user_id”,”logicTableName”:”t_new_order”,”values”:[“UD020003011903261545436593200002”]} ，包含：分片列名，逻辑表名，当前列的具体分片值</td>
</tr>
</tbody>
</table>
<p>该方法返回值为 </p>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Collection＜String＞</td>
<td style="text-align:left">分片结果，可以是目标数据源，也可以是目标数据表，此处为数据源</td>
</tr>
</tbody>
</table>
<p>接着回来看业务逻辑，伪代码如下</p>
<ol>
<li><p>首先打印了一下数据源集合 availableTargetNames 以及 分片属性 shardingValues的值，执行测试用例后，日志输出为：</p>
<pre><code>availableTargetNames:[&quot;ds0&quot;,&quot;ds1&quot;,&quot;ds2&quot;,&quot;ds3&quot;],
shardingValues:[{&quot;columnName&quot;:&quot;user_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;UD020003011903261545436593200002&quot;]},
                {&quot;columnName&quot;:&quot;order_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;OD000000011903261545475143200001&quot;]}]
</code></pre></li>
</ol>
<blockquote>
<p>从日志可以看出，我们可以在该路由方法中取到配置时的物理数据源列表，以及在运行时获取本次执行时的路由属性及其值</p>
</blockquote>
<p>完整的逻辑流程如下：</p>
<ol>
<li>定义一个集合用于放置最终匹配好的路由数据源，接着对shardingValues进行遍历，目的为至少命中一个路由键</li>
<li>遍历shardingValues循环体中，打印了当前循环的shardingValue，即实际的分片键的数值，如：订单号、用户id等。通过getIndex方法，获取该分片键值中包含的物理数据源索引</li>
<li>接着遍历数据源列表availableTargetNames，截取当前循环对应availableTargetName的索引值，（eg: ds0则取0，ds1则取1…以此类推）将该配置的物理数据源索引与 <strong>第2步</strong> 中解析到的数据源路由索引进行比较，两者相等则表名我们期望将该数据路由到该匹配到的数据源。</li>
<li>执行这个过程，直到匹配到一个路由键则停止循环，之所以这么做是因为我们是复合分片，至少要匹配到一个路由规则，才能停止循环，最终将路由到的物理数据源（ds0/ds1/ds2/ds3）通过add方法添加到事先定义好的集合中并返回给框架。</li>
<li>逻辑结束。</li>
</ol>
<p>可能读者朋友对如何从shardingValue中解析数据源的索引不理解，这里讲解一下。</p>
<p>上一篇文章中，我们在自定义全局业务id时，定义了一个主键枚举，并在枚举中定义了主键中库、表索引存放的位置，详细内容请移步 <a href="http://wuwenliang.net/2019/03/25/%E8%B7%9F%E6%88%91%E5%AD%A6shardingjdbc%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%BB%E9%94%AE%E5%8F%8A%E5%85%B6%E8%87%AA%E5%AE%9A%E4%B9%89/">跟我学shardingjdbc之分布式主键及其自定义</a> , 到这里就简单了，Sharding-JDBC框架已经通过 <strong>doSharding(Collection availableTargetNames, Collection shardingValues)</strong> 方法将当前的路由键的值给了我们，也就是我们通过KeyGenerator生成的业务主键，我们只需要解析该主键，获取其中的库索引即可，代码逻辑如下：</p>
<pre><code>/**
 * 根据分片键计算分片节点
 * @param logicTableName
 * @param columnName
 * @param shardingValue
 * @return
 */
public String getIndex(String logicTableName, String columnName, String shardingValue) {
    String index = &quot;&quot;;
    if (StringUtils.isBlank(shardingValue)) {
        throw new IllegalArgumentException(&quot;分片键值为空&quot;);
    }
    //截取分片键值-下标循环主键规则枚举类，匹配主键列名得到规则
    for (DbAndTableEnum targetEnum : DbAndTableEnum.values()) {

        /**目标表路由
         * 如果逻辑表命中，判断路由键是否与列名相同
         */
        if (targetEnum.getTableName().equals(logicTableName)) {
            //目标表的目标主键路由-例如：根据订单id查询订单信息
            if (targetEnum.getShardingKey().equals(columnName)) {
                index = getDbIndexBySubString(targetEnum, shardingValue);
            }else{
                //目标表的非目标主键路由-例如：根据内部用户id查询订单信息-内部用户id路由-固定取按照用户表库表数量
                //兼容且仅限根据外部id路由 查询用户信息
                index = getDbIndexByMod(targetEnum, shardingValue);
            }
            break;
        }
    }
    if (StringUtils.isBlank(index)) {
        String msg = &quot;从分片键值中解析数据库索引异常：logicTableName=&quot; + logicTableName + &quot;|columnName=&quot; + columnName + &quot;|shardingValue=&quot; + shardingValue;
        throw new IllegalArgumentException(msg);
    }
    return index;
}
</code></pre><p> 分析一下逻辑：</p>
<ol>
<li>由于我们无法直接将当前的逻辑表对应到定义好的分库分表规则枚举，因此对  DbAndTableEnum进行遍历，这里用到了枚举的 <strong>values()</strong> 方法 ，对该方法的解析，放在了文章的 <a href="#end">附录</a> 中。</li>
<li>在每一轮循环中，我们将枚举规则中定义的逻辑表名与ShardingValue中的逻辑表名比较，相等表名路由是正确的，则继续比对路由ShardingValue中的路由键key与枚举中定义的key是否相等（如：order_id），相等则通过String.subString(int beginIndex, int endIndex)方法截取当前分片键值（如：OD000000011903261545475143200001）中的数据库的索引，注意去掉前面补位的0。结束循环并将该库索引返回</li>
<li>如果匹配逻辑表成功，匹配分片键失败，我们认为是使用了外部主键（如：使用用户user_id查询了订单信息）则通过取模方式进行取库下标操作。这样就同时支持了通过主键、外部id的方式进行查询。</li>
</ol>
<h3 id="开发自定义复合分表策略"><a href="#开发自定义复合分表策略" class="headerlink" title="开发自定义复合分表策略"></a>开发自定义复合分表策略</h3><blockquote>
<p>完成了数据源的路由，我们接着实现对数据表的路由策略。</p>
</blockquote>
<p>方法基本和实现数据源路由相同，也是要实现 <strong>ComplexKeysShardingAlgorithm</strong>  接口。需要重写其 <strong>doSharding(Collection availableTargetNames, Collection shardingValues)</strong> 方法。</p>
<p>区别在于分表策略的目的是选择物理表索引，最终告知Sharding-JDBC将数据发往分片的那个物理分表上。</p>
<p>建立复合分表策略SnoWalkerComplexShardingTB.java，代码实现如下：</p>
<pre><code>@Override
public Collection&lt;String&gt; doSharding(Collection&lt;String&gt; availableTargetNames, Collection&lt;ShardingValue&gt; shardingValues) {
    // 1. 打印物理分表集合 及 分片键属性集合
    log.info(&quot;availableTargetNames:&quot; + JSON.toJSONString(availableTargetNames) + &quot;,shardingValues:&quot; + JSON.toJSONString(shardingValues));

    // availableTargetNames:[&quot;t_new_order_0000&quot;,&quot;t_new_order_0001&quot;],
    // shardingValues:[{&quot;columnName&quot;:&quot;order_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;OD010001011903261549424993200011&quot;]},{&quot;columnName&quot;:&quot;user_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;UD030001011903261549424973200007&quot;]}]
    Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();
    // 2. 遍历分片键集合
    for (ShardingValue var : shardingValues) {
        // 2.1 逻辑与分库逻辑相同，转换ShardingValue为ListShardingValue
        ListShardingValue&lt;String&gt; listShardingValue = (ListShardingValue&lt;String&gt;)var;
        List&lt;String&gt; shardingValue = (List&lt;String&gt;)listShardingValue.getValues();
        // 3. 打印当前分片键的真实值
        // shardingValue:[&quot;OD010001011903261549424993200011&quot;]
        log.info(&quot;shardingValue:&quot; + JSON.toJSONString(shardingValue));

        // 4. 根据分片键的真实值获取数据分表索引值
        String index = getIndex(listShardingValue.getLogicTableName(),                              listShardingValue.getColumnName(),
                                   shardingValue.get(0));
        // 5. 循环匹配数据表，通过String.endsWith(String suffix)
        // 判断第4步中获取到的索引是否包含在当前循环的物理分表中，
        // （如：判断t_new_order_0000中是否包含“_0000”）
        // 从而证明当前数据匹配物理分表成功。
        for (String availableTargetName : availableTargetNames) {
            if (availableTargetName.endsWith(&quot;_&quot; + index)) {
                collection.add(availableTargetName);
                break;
            }
        }
        // 6. 只要匹配成功一种路由规则就退出
        if (collection.size() &gt; 0) {
            break;
        }
    }
    // 7. 返回表路由结果
    return collection;
}   
</code></pre><h4 id="核心逻辑解析-1"><a href="#核心逻辑解析-1" class="headerlink" title="核心逻辑解析"></a>核心逻辑解析</h4><p>可以看到基本上和物理分片路由规则相似，区别在于此处是选取物理分表，注释中已经写得比较详细了，着重讲一下第四、五步。</p>
<p>第四步中，通过和之前物理分片取索引的相同算法取到分片键中的分表值，然后通过 <strong>String.endsWith(String suffix)</strong> 判断availableTargetName是否以 “_” + 分表索引值 结尾，如果是，则表明匹配物理分表成功，将该物理分表的完整表名（如：t_new_order_0000）添加到事先定义好的路由集合中，返回给Sharding-JDBC供其回调。</p>
<p>此处再贴一下getIndex方法，以便加深读者理解。</p>
<pre><code>/**
 * 根据分片键计算分片节点
 * @param logicTableName
 * @param columnName
 * @param shardingValue
 * @return
 */
public String getIndex(String logicTableName,String columnName,String shardingValue) {
    String index = &quot;&quot;;
    if (StringUtils.isBlank(shardingValue)) {
        throw new IllegalArgumentException(&quot;分片键值为空&quot;);
    }
    //截取分片键值-下标循环主键规则枚举类，匹配主键列名得到规则
    for (DbAndTableEnum targetEnum : DbAndTableEnum.values()) {
        //目标表路由
        if (targetEnum.getTableName().equals(logicTableName)) {
            //目标表的目标主键路由-例如：根据订单id查询订单信息
            if (targetEnum.getShardingKey().equals(columnName)) {
                index = getTbIndexBySubString(targetEnum, shardingValue);
            }else{
                //目标表的非目标主键路由-例如：根据内部用户id查询订单信息-内部用户id路由-固定取按照用户表库表数量
                //兼容且仅限根据外部id查询用户信息
                index = getTbIndexByMod(targetEnum, shardingValue);
            }
            break;
        }
    }
    if (StringUtils.isBlank(index)) {
        String msg = &quot;从分片键值中解析表索引异常：logicTableName=&quot; + logicTableName + &quot;|columnName=&quot; + columnName + &quot;|shardingValue=&quot; + shardingValue;
        throw new IllegalArgumentException(msg);
    }
    return index;
}
</code></pre><p>完整的代码请移步 <a href="https://github.com/TaXueWWL/snowalker-shardingjdbc-demo" target="_blank" rel="external">snowalker-shardingjdbc-demo</a> ，分库分表策略代码路径如下：</p>
<pre><code>## 自定义分库策略实现类路径
com.snowalker.shardingjdbc.snowalker.demo.complex.sharding
    .strategy.SnoWalkerComplexShardingTB
## 自定义分表策略实现类路径
com.snowalker.shardingjdbc.snowalker.demo.complex.sharding
    .strategy.SnoWalkerComplexShardingDB
</code></pre><p>到这里，我们就完成了自定义复合分库分表策略的开发，接下来就写几个测试用例实际测试一下。</p>
<h3 id="测试前置–配置自定义分库分表策略"><a href="#测试前置–配置自定义分库分表策略" class="headerlink" title="测试前置–配置自定义分库分表策略"></a>测试前置–配置自定义分库分表策略</h3><blockquote>
<p>这里以订单表t_new_order_0000 – t_new_order_0001的配置为例，在分片配置文件中添加如下配置项，将分库、分表策略指向我们定义好的策略类。</p>
</blockquote>
<pre><code>###############################################################
#
#                    shardingjdbc--分片规则--复合分片--订单表
#           根据user_id取模分库, 且根据order_id取模分表的两库两表的配置。
#
###############################################################
#订单表多分片键策略配置
sharding.jdbc.config.sharding.tables.t_new_order.actualDataNodes
    =ds$-&gt;{0..3}.t_new_order_000$-&gt;{0..1}
#指定分库分片键
sharding.jdbc.config.sharding.tables.t_new_order.databaseStrategy.complex.shardingColumns
    =user_id,order_id
#指定自定义分库策略类
sharding.jdbc.config.sharding.tables.t_new_order.databaseStrategy.complex.algorithmClassName
    =com.snowalker.shardingjdbc.snowalker.demo.complex.sharding.strategy.SnoWalkerComplexShardingDB
#指定分表分片键
sharding.jdbc.config.sharding.tables.t_new_order.tableStrategy.complex.shardingColumns
    =user_id,order_id
#指定自定义分表策略类
sharding.jdbc.config.sharding.tables.t_new_order.tableStrategy.complex.algorithmClassName
    =com.snowalker.shardingjdbc.snowalker.demo.complex.sharding.strategy.SnoWalkerComplexShardingTB
</code></pre><p><strong>注意</strong> 指定分片实现类时，一定要使用全限定名。Sharding-JDBC会解析配置文件后帮我们加载自定义的分片策略。</p>
<h3 id="测试用例A–新增订单数据"><a href="#测试用例A–新增订单数据" class="headerlink" title="测试用例A–新增订单数据"></a>测试用例A–新增订单数据</h3><p>测试用例代码如下：</p>
<pre><code>/**
 * 测试订单入库
 */
@Test
public void testNewOrderInsert() {
    // 支付宝或者微信uid
    String outId = &quot;1232132131241241243126&quot;;
    LOGGER.info(&quot;获取id开始&quot;);
    String innerUserId = keyGenerator.generateKey(DbAndTableEnum.T_USER, outId);
    LOGGER.info(&quot;外部id={},内部用户={}&quot;, outId, innerUserId);
    String orderId = keyGenerator.generateKey(DbAndTableEnum.T_NEW_ORDER, innerUserId);
    LOGGER.info(&quot;外部id={},内部用户={},订单={}&quot;, outId, innerUserId, orderId);
    OrderNewInfoEntity orderInfo = new OrderNewInfoEntity();
    orderInfo.setUserName(&quot;snowalker&quot;);
    orderInfo.setUserId(innerUserId);
    orderInfo.setOrderId(orderId);
    orderNewSerivce.addOrder(orderInfo);

}
</code></pre><p>执行用例，日志打印如下：</p>
<pre><code>2019-03-26 21:25:31.296  INFO 12996 --- [           main] nowalkerShardingjdbcDemoApplicationTests : 
    获取id开始
2019-03-26 21:25:34.755  INFO 12996 --- [           main] nowalkerShardingjdbcDemoApplicationTests : 
外部id=12321321312412412431260,内部用户=UD020000011903262125313013200040
2019-03-26 21:25:34.758  INFO 12996 --- [           main] nowalkerShardingjdbcDemoApplicationTests : 
外部id=12321321312412412431260,内部用户=UD020000011903262125313013200040,订单=OD000000011903262125347553200121
2019-03-26 21:25:34.758  INFO 12996 --- [           main] c.s.s.s.d.c.s.service.OrderNewSerivce    : 
订单入库开始，orderinfo=OrderNewInfoEntity{id=null, userId=&apos;UD020000011903262125313013200040&apos;, orderId=&apos;OD000000011903262125347553200121&apos;, userName=&apos;snowalker&apos;}
2019-03-26 21:25:34.921  INFO 12996 --- [           main] s.s.s.d.c.s.s.SnoWalkerComplexShardingDB : 
availableTargetNames:[&quot;ds0&quot;,&quot;ds1&quot;,&quot;ds2&quot;,&quot;ds3&quot;],shardingValues:[{&quot;columnName&quot;:&quot;user_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;UD020000011903262125313013200040&quot;]},{&quot;columnName&quot;:&quot;order_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;OD000000011903262125347553200121&quot;]}]
2019-03-26 21:25:34.921  INFO 12996 --- [           main] s.s.s.d.c.s.s.SnoWalkerComplexShardingDB : 
shardingValue:[&quot;UD020000011903262125313013200040&quot;]
2019-03-26 21:25:34.921  INFO 12996 --- [           main] s.s.s.d.c.s.s.SnoWalkerComplexShardingTB : 
availableTargetNames:[&quot;t_new_order_0000&quot;,&quot;t_new_order_0001&quot;],shardingValues:[{&quot;columnName&quot;:&quot;user_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;UD020000011903262125313013200040&quot;]},{&quot;columnName&quot;:&quot;order_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;OD000000011903262125347553200121&quot;]}]
2019-03-26 21:25:34.921  INFO 12996 --- [           main] s.s.s.d.c.s.s.SnoWalkerComplexShardingTB : 
shardingValue:[&quot;UD020000011903262125313013200040&quot;]
2019-03-26 21:25:34.928  INFO 12996 --- [           main] Sharding-Sphere-SQL                      : Rule Type: sharding
2019-03-26 21:25:34.928  INFO 12996 --- [           main] Sharding-Sphere-SQL                      : 
    Logic SQL: insert into t_new_order(
            user_id,
            order_id,
            user_name
        )
        values
        (
            ?,
            ?,
            ?
        )
......
2019-03-26 21:25:34.928  INFO 12996 --- [           main] Sharding-Sphere-SQL                      : 
Actual SQL: ds0 ::: insert into t_new_order_0000(
        user_id,
        order_id,
        user_name
    )
    values
    (
        ?,
        ?,
        ?
    ) ::: [[UD020000011903262125313013200040, OD000000011903262125347553200121, snowalker]]
</code></pre><p>可以看到，我们生成的订单号OD000000011903262125347553200121被路由到ds0的t_new_order_0000表，这和我们的订单号中的第四位到第九位的 00（库）0000（表）吻合，表明我们的策略配合主键生成器生效了且是符合预期要求的。</p>
<h3 id="测试用例B–通过订单号查询订单明细"><a href="#测试用例B–通过订单号查询订单明细" class="headerlink" title="测试用例B–通过订单号查询订单明细"></a>测试用例B–通过订单号查询订单明细</h3><p>测试用例代码如下：</p>
<pre><code>/**
 * 测试订单明细查询
 */
@Test
public void testQueryNewOrderById() {
    String orderId = &quot;OD010001011903261549424993200011&quot;;
    String userId = &quot;UD030001011903261549424973200007&quot;;
    OrderNewInfoEntity orderInfo = new OrderNewInfoEntity();
    orderInfo.setOrderId(orderId);
    orderInfo.setUserId(userId);
    System.out.println(orderNewSerivce.queryOrderInfoByOrderId(orderInfo));
}
</code></pre><p>我们要查询订单号为OD010001011903261549424993200011，用户id=UD030001011903261549424973200007的订单明细，执行该测试用例，日志打印如下：</p>
<pre><code>2019-03-26 21:32:16.459  INFO 16140 --- [           main] s.s.s.d.c.s.s.SnoWalkerComplexShardingDB : 
availableTargetNames:[&quot;ds0&quot;,&quot;ds1&quot;,&quot;ds2&quot;,&quot;ds3&quot;],shardingValues:[{&quot;columnName&quot;:&quot;order_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;OD010001011903261549424993200011&quot;]},{&quot;columnName&quot;:&quot;user_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;UD030001011903261549424973200007&quot;]}]
2019-03-26 21:32:16.459  INFO 16140 --- [           main] s.s.s.d.c.s.s.SnoWalkerComplexShardingDB : 
shardingValue:[&quot;OD010001011903261549424993200011&quot;]
2019-03-26 21:32:16.466  INFO 16140 --- [           main] s.s.s.d.c.s.s.SnoWalkerComplexShardingTB : 
availableTargetNames:[&quot;t_new_order_0000&quot;,&quot;t_new_order_0001&quot;],shardingValues:[{&quot;columnName&quot;:&quot;order_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;OD010001011903261549424993200011&quot;]},{&quot;columnName&quot;:&quot;user_id&quot;,&quot;logicTableName&quot;:&quot;t_new_order&quot;,&quot;values&quot;:[&quot;UD030001011903261549424973200007&quot;]}]
2019-03-26 21:32:16.466  INFO 16140 --- [           main] s.s.s.d.c.s.s.SnoWalkerComplexShardingTB : 
shardingValue:[&quot;OD010001011903261549424993200011&quot;]
2019-03-26 21:32:16.474  INFO 16140 --- [           main] Sharding-Sphere-SQL                      : Rule Type: sharding
2019-03-26 21:32:16.475  INFO 16140 --- [           main] Sharding-Sphere-SQL                      : 
Logic SQL: select
            t.id as id,
            t.user_id as userId,
            t.order_id as orderId,
            t.user_name as userName
        from t_new_order t
        where t.order_id=?
        and t.user_id=?
......
2019-03-26 21:32:16.476  INFO 16140 --- [           main] Sharding-Sphere-SQL                      : 
Actual SQL: ds1 ::: select
            t.id as id,
            t.user_id as userId,
            t.order_id as orderId,
            t.user_name as userName
        from t_new_order_0001 t
        where t.order_id=?
        and t.user_id=? ::: [[OD010001011903261549424993200011, UD030001011903261549424973200007]]
OrderNewInfoEntity{id=1249, userId=&apos;UD030001011903261549424973200007&apos;, orderId=&apos;OD010001011903261549424993200011&apos;, userName=&apos;snowalker&apos;}
</code></pre><p>sql中传入了两个查询条件，首先匹配到的是order_id，因此先按照order_id进行路由，找到ds1的t_new_order_0001表，在该表中执行真实查询SQL如下</p>
<pre><code>select
    t.id as id,
    t.user_id as userId,
    t.order_id as orderId,
    t.user_name as userName
from t_new_order_0001 t
where t.order_id=?
and t.user_id=? ::: [[OD010001011903261549424993200011, UD030001011903261549424973200007]]
</code></pre><p>查询结果为</p>
<pre><code>OrderNewInfoEntity{id=1249, 
    userId=&apos;UD030001011903261549424973200007&apos;, orderId=&apos;OD010001011903261549424993200011&apos;, 
    userName=&apos;snowalker&apos;}
</code></pre><p>可以看到，依旧满足我们的要求，表明我们的复合路由策略是正确的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文中，我们结合之前的自定义分布式主键，完成了Sharding-JDBC中复合分片路由算法的自定义实现，并经过测试验证符合预期。</p>
<p>该实现方案在生产上已经经历过考验，读者可以借鉴并运用到自己的项目中。</p>
<p>定义分片路由策略的核心还是要熟悉ComplexKeysShardingAlgorithm，对如何解析 doSharding(Collection<string> availableTargetNames, Collection<shardingvalue> shardingValues)的参数有明确的认识，最简单的方法就是实际打印一下参数，相信会让你更加直观的感受到作者优良的接口设计能力，站在巨人的肩膀上我们能看到更远。</shardingvalue></string></p>
<p>到此，跟我学Sharding-JDBC系列就告一段落，后续待笔者功力精进，会对该框架的源码做进一步的解析，让我们不见不散。</p>
<p><a href="https://github.com/TaXueWWL/snowalker-shardingjdbc-demo" target="_blank" rel="external">跟我学Sharding-JDBC源码github地址</a></p>
<h2 id="附录：解析枚举类的values-方法"><a href="#附录：解析枚举类的values-方法" class="headerlink" title="附录：解析枚举类的values()方法"></a><a name="end">附录：解析枚举类的values()方法</a></h2><blockquote>
<p>枚举的 <strong>values()</strong> 方法 是编译器生成的static方法，因此在Enum类中并没出现values()方法，它是编译器编译枚举类后添加的。values()方法的作用就是获取枚举类中的所有变量，并作为数组返回。</p>
<p>注意，由于values()方法是编译器插入到枚举类中的static方法，所以如果我们将枚举实例向上转型为Enum，则values()方法将无法被调用，因为Enum类中并没有values()方法，valueOf()方法也是同样的道理，注意是一个参数的。</p>
</blockquote>
<p>参考链接：</p>
<p><a href="https://www.cnblogs.com/alter888/p/9163612.html" target="_blank" rel="external">深入理解Java枚举类型(enum)</a></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Sharding-JDBC/">Sharding-JDBC</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Sharding-JDBC/">Sharding-JDBC</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://wuwenliang.net/2019/03/26/跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现/" data-title="跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现 | 朝·闻·道" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/03/28/跟我学RocketMQ之消息重试/" title="跟我学RocketMQ之消息重试">
  <strong>上一篇：</strong><br/>
  <span>
  跟我学RocketMQ之消息重试</span>
</a>
</div>


<div class="next">
<a href="/2019/03/25/跟我学shardingjdbc之分布式主键及其自定义/"  title="跟我学shardingjdbc之分布式主键及其自定义">
 <strong>下一篇：</strong><br/> 
 <span>跟我学shardingjdbc之分布式主键及其自定义
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2019/03/26/跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现/" data-title="跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现" data-url="http://wuwenliang.net/2019/03/26/跟我学shardingjdbc之自定义分库分表策略-复合分片算法自定义实现/"></div>
</section>




</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#了解Sharding-JDBC的数据分片策略"><span class="toc-number">1.</span> <span class="toc-text">了解Sharding-JDBC的数据分片策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#精确分片算法–PreciseShardingAlgorithm"><span class="toc-number">1.1.</span> <span class="toc-text">精确分片算法–PreciseShardingAlgorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#范围分片算法–RangeShardingAlgorithm"><span class="toc-number">1.2.</span> <span class="toc-text">范围分片算法–RangeShardingAlgorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复合分片算法–ComplexKeysShardingAlgorithm"><span class="toc-number">1.3.</span> <span class="toc-text">复合分片算法–ComplexKeysShardingAlgorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hint分片算法–HintShardingAlgorithm"><span class="toc-number">1.4.</span> <span class="toc-text">Hint分片算法–HintShardingAlgorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准分片策略–StandardShardingStrategy"><span class="toc-number">1.5.</span> <span class="toc-text">标准分片策略–StandardShardingStrategy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复合分片策略–ComplexShardingStrategy"><span class="toc-number">1.6.</span> <span class="toc-text">复合分片策略–ComplexShardingStrategy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#行表达式分片策略–InlineShardingStrategy"><span class="toc-number">1.7.</span> <span class="toc-text">行表达式分片策略–InlineShardingStrategy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hint分片策略–HintShardingStrategy"><span class="toc-number">1.8.</span> <span class="toc-text">Hint分片策略–HintShardingStrategy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不分片策略–NoneShardingStrategy"><span class="toc-number">1.9.</span> <span class="toc-text">不分片策略–NoneShardingStrategy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实战–自定义复合分片策略"><span class="toc-number">2.</span> <span class="toc-text">实战–自定义复合分片策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#场景回顾"><span class="toc-number">2.1.</span> <span class="toc-text">场景回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开发自定义复合分库策略"><span class="toc-number">2.2.</span> <span class="toc-text">开发自定义复合分库策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#核心逻辑"><span class="toc-number">2.2.1.</span> <span class="toc-text">核心逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#核心逻辑解析"><span class="toc-number">2.2.2.</span> <span class="toc-text">核心逻辑解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开发自定义复合分表策略"><span class="toc-number">2.3.</span> <span class="toc-text">开发自定义复合分表策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#核心逻辑解析-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">核心逻辑解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试前置–配置自定义分库分表策略"><span class="toc-number">2.4.</span> <span class="toc-text">测试前置–配置自定义分库分表策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试用例A–新增订单数据"><span class="toc-number">2.5.</span> <span class="toc-text">测试用例A–新增订单数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试用例B–通过订单号查询订单明细"><span class="toc-number">2.6.</span> <span class="toc-text">测试用例B–通过订单号查询订单明细</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录：解析枚举类的values-方法"><span class="toc-number">4.</span> <span class="toc-text">附录：解析枚举类的values()方法</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Dubbo/" title="Dubbo">Dubbo<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/ELK-Stack/" title="ELK-Stack">ELK-Stack<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/HTTPS/" title="HTTPS">HTTPS<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo/" title="Hexo">Hexo<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/JDK-concurrent/" title="JDK-concurrent">JDK-concurrent<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/JDK源码解析/" title="JDK源码解析">JDK源码解析<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>22</sup></a></li>
		  
		
		  
			<li><a href="/categories/KindEditor/" title="KindEditor">KindEditor<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Redis/" title="Redis">Redis<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/SSO/" title="SSO">SSO<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/SpringCloud/" title="SpringCloud">SpringCloud<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tomcat/" title="Tomcat">Tomcat<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/auth/" title="auth">auth<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/docker/" title="docker">docker<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/hexo/" title="hexo">hexo<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/kubernates/" title="kubernates">kubernates<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/maven/" title="maven">maven<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/mybatis/" title="mybatis">mybatis<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/mysql/" title="mysql">mysql<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/nginx/" title="nginx">nginx<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/nginx-负载均衡/" title="nginx, 负载均衡">nginx, 负载均衡<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/spring-boot/" title="spring-boot">spring-boot<sup>25</sup></a></li>
		  
		
		  
			<li><a href="/categories/springboot/" title="springboot">springboot<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/web/" title="web">web<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/与你同行/" title="与你同行">与你同行<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/专题-分布式/" title="专题-分布式">专题-分布式<sup>13</sup></a></li>
		  
		
		  
			<li><a href="/categories/代理模式-工作总结-入职感受/" title="代理模式,工作总结,入职感受">代理模式,工作总结,入职感受<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/分布式-Dubbo/" title="分布式 Dubbo">分布式 Dubbo<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/单例模式/" title="单例模式">单例模式<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/年度总结/" title="年度总结">年度总结<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/数据库/" title="数据库">数据库<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/架构/" title="架构">架构<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/汇总盘点推荐/" title="汇总盘点推荐">汇总盘点推荐<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/爬虫/" title="爬虫">爬虫<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/电话面试/" title="电话面试">电话面试<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/自己写分布式组件系列/" title="自己写分布式组件系列">自己写分布式组件系列<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/跟我学RocketMQ/" title="跟我学RocketMQ">跟我学RocketMQ<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/随笔/" title="随笔">随笔<sup>5</sup></a></li>
		  
		
		</ul>
</div>


  
  <div class="tagcloudlist">
    <p class="asidetitle">标签云</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/Dubbo/" style="font-size: 13.33px;">Dubbo</a> <a href="/tags/ELK-Stack/" style="font-size: 15.56px;">ELK-Stack</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JDK-concurrent/" style="font-size: 12.22px;">JDK-concurrent</a> <a href="/tags/JDK源码解析/" style="font-size: 13.33px;">JDK源码解析</a> <a href="/tags/Java/" style="font-size: 18.89px;">Java</a> <a href="/tags/KindEditor/" style="font-size: 10px;">KindEditor</a> <a href="/tags/Linux/" style="font-size: 11.11px;">Linux</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SSO-单点登录/" style="font-size: 10px;">SSO,单点登录</a> <a href="/tags/Sharding-JDBC/" style="font-size: 13.33px;">Sharding-JDBC</a> <a href="/tags/SpringCloud/" style="font-size: 10px;">SpringCloud</a> <a href="/tags/Tomcat/" style="font-size: 11.11px;">Tomcat</a> <a href="/tags/auth/" style="font-size: 11.11px;">auth</a> <a href="/tags/docker/" style="font-size: 12.22px;">docker</a> <a href="/tags/hexo/" style="font-size: 11.11px;">hexo</a> <a href="/tags/kubernates/" style="font-size: 10px;">kubernates</a> <a href="/tags/maven/" style="font-size: 12.22px;">maven</a> <a href="/tags/mybatis/" style="font-size: 11.11px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 14.44px;">mysql</a> <a href="/tags/nginx/" style="font-size: 11.11px;">nginx</a> <a href="/tags/spring-boot/" style="font-size: 20px;">spring-boot</a> <a href="/tags/springboot/" style="font-size: 10px;">springboot</a> <a href="/tags/web/" style="font-size: 13.33px;">web</a> <a href="/tags/与你同行/" style="font-size: 10px;">与你同行</a> <a href="/tags/专题-分布式/" style="font-size: 17.78px;">专题-分布式</a> <a href="/tags/代理模式-工作总结-入职感受/" style="font-size: 10px;">代理模式,工作总结,入职感受</a> <a href="/tags/分布式-Dubbo/" style="font-size: 13.33px;">分布式 Dubbo</a> <a href="/tags/单例模式-懒加载/" style="font-size: 10px;">单例模式, 懒加载</a> <a href="/tags/年度总结/" style="font-size: 12.22px;">年度总结</a> <a href="/tags/我们的爱情/" style="font-size: 10px;">我们的爱情</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/汇总盘点推荐/" style="font-size: 10px;">汇总盘点推荐</a> <a href="/tags/爬虫-WebMagic/" style="font-size: 10px;">爬虫,WebMagic</a> <a href="/tags/电话面试/" style="font-size: 10px;">电话面试</a> <a href="/tags/秒杀/" style="font-size: 10px;">秒杀</a> <a href="/tags/自己写分布式组件系列/" style="font-size: 16.67px;">自己写分布式组件系列</a> <a href="/tags/跟我学RocketMQ/" style="font-size: 15.56px;">跟我学RocketMQ</a> <a href="/tags/随笔/" style="font-size: 14.44px;">随笔</a>
    </div>
  </div>


  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="TaXueWWL" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/spring-boot/" title="spring-boot">spring-boot<sup>25</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>22</sup></a></li>
			
		
			
				<li><a href="/tags/专题-分布式/" title="专题-分布式">专题-分布式<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/自己写分布式组件系列/" title="自己写分布式组件系列">自己写分布式组件系列<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/ELK-Stack/" title="ELK-Stack">ELK-Stack<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/跟我学RocketMQ/" title="跟我学RocketMQ">跟我学RocketMQ<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/mysql/" title="mysql">mysql<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/随笔/" title="随笔">随笔<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/JDK源码解析/" title="JDK源码解析">JDK源码解析<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/web/" title="web">web<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/分布式-Dubbo/" title="分布式 Dubbo">分布式 Dubbo<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Dubbo/" title="Dubbo">Dubbo<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/maven/" title="maven">maven<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/年度总结/" title="年度总结">年度总结<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/JDK-concurrent/" title="JDK-concurrent">JDK-concurrent<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/docker/" title="docker">docker<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/mybatis/" title="mybatis">mybatis<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/auth/" title="auth">auth<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/nginx/" title="nginx">nginx<sup>2</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="undefined" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p>  <br/>
			惟精惟一，允执厥中 朝闻道，夕死可矣</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/TaXueWWL" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/TaXueWWL" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:wuwenliangsn@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="SnoWalker">SnoWalker</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"snowalker"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>

<a href="https://github.com/TaXueWWL" target="_blank"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png" alt="Fork me on GitHub"></a>